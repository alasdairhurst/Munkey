import crypto from 'crypto';
import db from 'db';
const cryptoConf = global.$config.crypto;
const defaultFields = [
	'id',
	'username',
	'created_at',
	'updated_at',
	'data'
];

/**
 * Create a new user
 * @param opts the username and password to create the user with
 * @returns {Promise.<T>}
 * @constructor
 */
export function CreateUser(opts) {
	return new Promise((resolve, reject) => {
		const {username, password} = opts;

		if (!username) {return reject(new Error('Username Required'));}
		if (!password) {return reject(new Error('Password Required'));}

		const user = {
			username,
			...hashAndSalt(password),
			created_at: new Date,
			updated_at: new Date
		};

		return resolve(user);
	})
	.then(user => {
		return db('users').insert(user);
	})
}

/**
 * Fetch the user from the database
 * @param opts
 * @returns {*}
 * @constructor
 */
export function GetUser(opts = {fields: defaultFields}) {
	return db.select(...opts.fields).from('users')
		.then((users) => {
			return new Promise((resolve, reject) => {
				resolve(users[0]);
			});
		});
}

/**
 * Updates the user in the database with new fields
 * @param opts.user the user to update
 * @param opts.update.password new password for the user
 * @param opts.update.data new data for the user
 * @constructor
 */
export function UpdateUser(opts) {
	return new Promise((resolve, reject) => {
		const update = {};
		if (opts.update.password) {
			// get a new password hash and salt for the user
			Object.assign(update, hashAndSalt(opts.update.password));
		}
		opts.update.data && (update.data = opts.update.data);
		update.updated_at = new Date;
		return resolve({user:opts.user, update});
	})
	.then((opts) => {
		const {user, update} = opts;
		return db('users')
			.where('username', '=', user.username)
			.update(update);
	});
}

/**
 * takes a password, salts it and returns the salt and salted password
 * @param password password to salt
 * @param salt (optional) the salt to add to the password.
 * @returns {{password_salt: *, password: *}}
 */
function hashAndSalt(password, salt = crypto.randomBytes(cryptoConf.salt.bytes).toString('base64')) {
	const hash = crypto.pbkdf2Sync(password, salt, cryptoConf.hash.iterations, 256, 'sha256');
	return {
		password_salt: salt,
		password: hash.toString('base64')
	};
}

/**
 * Matches a password query to the password on a user doc
 * @param opts.password the password passed in through a query
 * @param opts.user the user DB doc containing the password and password salt
 * @returns {boolean}
 */
export function MatchPasswords(opts) {
	if (!opts.user.password_salt) {
		console.error("Cannot match passwords without existing salt");
		return false;
	}
	const password = hashAndSalt(opts.password, opts.user.password_salt).password;
	return password === opts.user.password;
}


